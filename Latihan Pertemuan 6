Fibbonacci dengan while

#Fibbonacci dengan while
nterms = int(input("How many terms? "))
n1, n2 = 0, 1
count = 0

if nterms <= 0:
    print("Please enter a positive integer")
elif nterms == 1:
    print("Fibbonacci sequence upto ", nterms,": ")
    print(n1)
else:
    print("Fibbonacci sequence: ")
    while count < nterms:
        print(n1)
        nth = n1 + n2
        #update nilai
        n1 = n2
        n2 = nth
        count += 1
---------------------------------------------------------------------------------------------------------------------------
output:

Fibonacci sequence: 20
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181

===========================================================================================================================
Fibbonacci dengan rekursi

#Fibbonacci dengan rekursi
def recur_fibo(n):
    if n <= 1:
        return n
    else:
        return(recur_fibo(n-1) + recur_fibo(n-2))

#nterms = 30 # tanpa input
nterms = int(input("How many terms? ")) # bisa input

#cek apakah nilai nterms valid
if nterms <= 0:
    print("Please enter a positive integer")
else:
    print("Fibonacci sequence: ")
    for i in range(nterms):
        print(recur_fibo(i))
---------------------------------------------------------------------------------------------------------------------------
output:

Fibonacci sequence: 
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
6765
10946
17711
28657
46368
75025
121393
196418
317811
51422
===========================================================================================================================
The Traveling Salesperson Problem

import matplotlib
import matplotlib.pyplot as plt
import random
import time
import itertools
---------------------------------------------------------------------------------------------------------------------------
# Try All Tours (exact_TSP)
def exact_TSP(cities):
    "Generate all possible tour of the cities and chose shortest one"
    return shortest(alltours(cities))

def shortest(tours):
    "Return the tour with the minimum total distance"
    return min(tours, key = total_distance)
---------------------------------------------------------------------------------------------------------------------------
# Representing Tours
alltours = itertools.permutations # The permutation function is already defined in the itertools module

cities = {1, 2, 3}

list(alltours(cities))
---------------------------------------------------------------------------------------------------------------------------
# Representing Cities and Distance
def total_distance(tour):
    "The total distance between each pair of consecutive cities in the tour."
    return sum(distance(tour[i], tour[i-1]) for i in range(len(tour)))
---------------------------------------------------------------------------------------------------------------------------
City = complex # constructor for new cities, e.g. City(300, 400)

def distance(A, B):
    "the distance between towo points."
    return abs(A - B)
---------------------------------------------------------------------------------------------------------------------------
A = City(300, 0)
B = City(0, 400)
distance(A, B)
---------------------------------------------------------------------------------------------------------------------------
def Cities(n):
    "make set of n cities, each with random coordinates."
    return set(City(random.randrange(10, 890), random.randrange(10, 590)) for c in range(n))

# let's make some standart sets of cities of various sizes.
# we'll set the random seed so that these sets are the same every time we run this notebook.
random.seed('seed')
cities8, cities10, cities100, cities1000 = Cities(8), Cities(10), Cities(100), Cities(1000)
cities8
---------------------------------------------------------------------------------------------------------------------------
tour = exact_TSP(cities8)

print(tour)
print(total_distance(tour))
---------------------------------------------------------------------------------------------------------------------------
# try all non-redundant tours
def alltours(cities):
    "return a list of tours, each a permutation of cities, but each one starting with the same city."
    start = first(cities)
    return[[start] + list(tour) for tour in itertools.permutations(cities - {start})]

def first(collection):
    "start iterating over collection, and return the first element."
    for x in collection: return x
---------------------------------------------------------------------------------------------------------------------------
alltours({1, 2, 3})
---------------------------------------------------------------------------------------------------------------------------
alltours({1, 2, 3, 4})
---------------------------------------------------------------------------------------------------------------------------
tour = exact_TSP(cities8)

print (tour)
print(total_distance(tour))
---------------------------------------------------------------------------------------------------------------------------
# plotting
import time
def plot_tour(algorithm, cities):
    "apply a TSP algorithm to cities, and plot the resulting tour."
    # find the solution and time how long it takes
    t0 = time.time()
    tour = algorithm(cities)
    t1 = time.time()
    # plot the tour as blue lines between blue circles, and the starting city as a red square.
    plotline(list(tour) + [tour[0]])
    plotline([tour[0]], 'rs')
    plt.show()
    print("{} city tour; total distance = {:.1f}; time = {:.3f} secs for {}".format(len(tour), total_distance(tour), t1-t0, algorithm.__name__))

def plotline(points, style='bo-'):
    "plot a list of points (complex numbers) in the 2-D plane."
    X, Y = XY(points)
    plt.plot(X, Y, style)
    
def XY(points):
    "given a list points, return two lists: X coordinates, and Y coordinates."
    return [p.real for p in points], [p.imag for p in points]

plot_tour(exact_TSP, cities8)
---------------------------------------------------------------------------------------------------------------------------
plot_tour(exact_TSP, cities10)
---------------------------------------------------------------------------------------------------------------------------
# greedy nearest neighbor (greedy_TSP)

def greedy_TSP(cities):
    "at each step, visit the nearest neighbor that is still unvisited."
    start = first(cities)
    tour = [start]
    unvisited = cities - {start}
    while unvisited:
        C = nearest_neighbor(tour[-1], unvisited)
        tour.append(C)
        unvisited.remove(C)
    return tour

def nearest_neighbor(A, cities):
    "find the city in cities that is nearest to city A"
    return min(cities, key=lambda x: distance(x, A))
---------------------------------------------------------------------------------------------------------------------------
cities = Cities(9)
plot_tour(exact_TSP, cities)
plot_tour(greedy_TSP, cities)
---------------------------------------------------------------------------------------------------------------------------
plot_tour(greedy_TSP, cities100)
plot_tour(greedy_TSP, cities1000)
---------------------------------------------------------------------------------------------------------------------------
# algorithm 3: greedy nearest neighbor from all starting points (all_greedy_TSP)
def all_greedy_TSP(cities):
    "try the greedy algorithm from each of the starting cities; return the shortest tour."
    return shortest(greedy_TSP(cities, start = c) for c in cities)

# we will modify greedy_TSP to take an opsional start city: otherwise it is uncharged.

def greedy_TSP(cities, start = None):
    "at each step, visit the nearest neighbor that is still unvisited."
    start = first(cities)
    tour = [start]
    unvisited = cities - {start}
    while unvisited:
        C = nearest_neighbor(tour[-1], unvisited)
        tour.append(C)
        unvisited.remove(C)
    return tour
---------------------------------------------------------------------------------------------------------------------------
# compare greedy_TSP to all_greedy_TSP
plot_tour(greedy_TSP, cities100)
plot_tour(all_greedy_TSP, cities100)
---------------------------------------------------------------------------------------------------------------------------
# algorithm 4: greedy nearest neighbor with exact end (greedy_exact_end_TSP)

def greedy_exact_end_TSP(cities, start = None, end_size=0):
    """at each step, visit the nearest neighbor that is still unvisited until
    there are k_end cities left; then choose the best of all possible endings."""
    if start is None: start = first(cities)
    tour = [start]
    unvisited = cities - {start}
    # use greedy algorithm for all but the end_size cities
    while len(unvisited) > end_size:
        C = nearest_neighbor(tour[-1], unvisited)
        tour.append(C)
        unvisited.remove(C)
    # consider all permutations of possible ends to the tour, and choose the best one.
    # (but to make thingsfaster, omit the middle of the tour.)
    ends = map(list, itertools.permutations(unvisited))
    best = shortest([tour[0], tour[-1]] + end for end in ends)
    return tour + best[2:]
---------------------------------------------------------------------------------------------------------------------------
plot_tour(greedy_exact_end_TSP, cities100)
plot_tour(greedy_exact_end_TSP, cities1000)
---------------------------------------------------------------------------------------------------------------------------
# algorithm 5: greedy nearest neighbor with both ends search (greedy_bi_TSP)

def greedy_bi_TSP(cities, start_size = 12, end_size = 6):
    "at each step, visit the nearest neighbor that is still unvisited."
    starts = random.sample(cities, min(len(cities), start_size))
    return shortest(greedy_exact_end_TSP(cities, start, end_size)
                    for start in starts)

random.seed('bi-')
plot_tour(greedy_bi_TSP, cities100)
#plot_tour(greedy_bi_TSP, cities1000)
---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------










